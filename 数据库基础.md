关系型和非关系性数据库的区别？
关系型数据库的优点：
1、容易理解，因为它采用了关系模型来组织数据
2、可以保持数据的一致性
3、数据的更新开销比较小
4、支持复杂查询(带where子句查询)

非关系性数据库(NOSQL)的优点
1、无需经过SQL层的解析，读写效率高
2、基于键值对，读写性高，易于扩展
3、可以支持多种数据类型的存储，如图片，文档等
4、扩展（可分为内存数据库以及文档类型数据库，比如Redis、MongoDB、HBase等，适合场景：数据量大高可用的日志系统/地理位置存储系统）。

详细说明MySQL语句的执行步骤
Server层按循序执行SQL的步骤为：
1、客户端请求->连接器(验证用户身份，给予权限)
2、查询缓存(存在缓存则直接返回,不存在则执行后续操作)
3、分析器(主要对SQL语法分析操作)
4、优化器(主要对执行的SQL优化选择最优的执行方案)
5、执行器(执行时会看用户是否有权限，有才去使用这个引擎提供的接口)->去引擎层获取数据返回(如果开启查询缓存则会缓存查询结果)

MySQL使用索引的原因
根本原因
1、索引的出现，就是为了提高数据查询的效率，就像书本的目录一样
2、对于数据库的表而言，索引其实就是它的“目录”
扩展
1、创建唯一性索引，可以保持数据库表中没一行数据的唯一性
2、帮助引擎层避免排序和临时表
3、将随机IO变为顺序IO，加速表和表之间的连接

索引的三种常见底层数据结构以及优缺点
三种常见的索引底层数据结构：哈希表、有序数组、索引树
1、哈希表这种适合等值查询的场景，比如memcached以及其他一下NoSQL引擎，不适合范围查询
2、有序数组索引只适合静态存储引擎，等值和范围查询性能好，但更新数据成本高
3、N叉树由于读写上的性能优点以及适配磁盘访问模式以及广泛应用在数据库引擎中
4、扩展(以及InnoDB的一个整数字段索引为例，这个N差不多是1200，棵树高是4的时候，就可以存1200的3次方的值，这已经17亿次了。考虑到树根的数据库总是在内存中，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘，其实树的第二层也有很大的概率在内存中，那么访问磁盘的平均数就更少了)

索引的常见类型以及它是如何发挥作用？
根据叶子结点的内容，索引的常见类型分为主键索引和非主键索引
1、主键索引的叶子结点存的整行数据，在InnoDB中也被称为聚族索引
2、非主键索引叶子结点存的主键的值，在InnoDB中也被称为二级索引

MyISAM和InnoDB实现B树索引方式的区别是什么？
1、InnoDB存储引擎：B+树索引的叶子结点保存数据本身，其数据文件本身就是索引文件
2、MyISAM存储引擎：B+树索引的叶子结点保存数据的物理地址，叶子结点的data域存放的是数据的地址，索引文件和数据文件是分离的。

InnoDB为什么设计B+树索引
两个考虑因素：
1、InnoDB需要执行的场景和功能需要在查询上拥有较强的性能。
2、CPU将磁盘上的数据加载到内存中需要大量的时间
为什么选择B+树：
1、哈希索引虽然能提供O(1)复杂度查询，但对范围查询和排序却无法很好的支持，最终会导致全表扫描。
2、B树能够在非叶子结点存储数据，但会导致在查询连续数据可能带来更多的随机IO
3、而B+树的所有叶子结点可以通过指针来相互连接，减少顺序遍历带来的随机IO
4、普通索引还是唯一索引？
    由于唯一索引不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发建议优点考虑非唯一索引
    
什么是覆盖索引和索引下推
索引覆盖：
1、在某个查询里面，索引 K 已经“覆盖了”我们的查询需求，称为覆盖索引
2、覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段
唯一索引：
MySQL5.6引入的索引下推优化(index,condition,pushdown),可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数。

哪些操作会导致索引失效？
1、对索引使用左或者左右模糊匹配，也就是 like %xx 或者 like %xxx%这两种方式都会造成索引失效，原因在于查询的结果可能多个，不知道从哪个索引值比较开始，与就是只能通过扫描全表的方式来查询。
2、对索引进行函数/对索引进行表达式计算，因为索引保持的索引字段的原始值，而不是经过函数计算的值，自然就没法走索引
3、对索引进行隐式转换相当于使用了新的函数。
4、where子句中的 or 语句，只要有条件列不是索引列，就会进行全表扫描。

字符串加索引
1、直接创建完整索引，这样可能会比较占用空间
创建前缀索引，节省空间，但会增加查询扫描次数，而且不能使用覆盖索引。
2、倒叙索引，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题。
创建hash索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

MySQL的change buffer是什么
1、当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中
2、这样就不需要在磁盘中读取这个数据页了，在下次查询访问这个数据页的时候，将数据页读如内存，然后执行 change buffer 中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。
3、注意唯一索引的更新就不能使用change buffer，实际上也就有普通索引可以使用
适用场景
    ——对于写多读少的业务来说，页面在写完后马上被访问到的概率比较小，此时change buffer的使用效果最好，这种业务模型常见的就是账单，日志的系统
    ——反过来，假设一个业务的更新模式是写入之后马上会做查询，那么既满足了条件，将更新记录在change buffer，但之后由于马上要访问这个数据页，会立即出发merge过程，这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价
    
    