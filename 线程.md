#### 线程

每当一个程序运行的时候就会变成进程，每个进程都有一个独享的内存空间

每个进程内部有多个线程组成，

多线程：在单个程序中同时运行多个线程完成不同的工作，称为多线程。



jvisualvm（进程监控器）



#### **继承thread与实现runnable的区别**

继承Thread实现的模式是  定义多个线程,各自完成各自的任务.  实现Runnable实现的模式是 定义多个线程,实现一个任务并且可以同时被多个线程共享

大多数情况下，如果只想重写 run() 方法，而不重写其他 Thread 方法，那么应使用 Runnable 接口

#### **start()方法和run()方法的区别**

只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码

java执行多线程是抢占式的，线程的执行0顺序具有不可控性。cpu会给他分配时间片，所以每次执行结果不一样

Java多线程环境下的执行的不确定性。CPU可能随机的在多个处于就绪状态中的线程中进行切换，因此，很有可能出现如下情况：当thread1执行到//1处代码时，判断条件为true，此时CPU切换到thread2，执行//1处代码，发现依然为真，然后执行完thread2，接着切换到thread1，接着执行完毕。此时，就会出现上述结果。

因此，讲到线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问

#### 死锁

如果两个线程（多个线程时情况类似）分别拥有不同的资源，而同时又需要对方释放资源才能继续运行时，就会发生死锁。

死锁就是多个线程在执行过程中，因竞争资源而造成的一种相互等待的现象，若无外力的作用，这些进程将无法向前推进。

#### 饿死

饿死（starvation） 是一个线程长时间得不到需要的资源而不能执行的现象。

一个线程在无限地等待另外两个或多个线程相互传递使用并且用不会释放的资源。

避免饿死就应该是采用队列的方式，保证每个人都有机会获得请求的资源。 当然实现方式可以很多个变化，比如优先级，时间片，等，都是“队列”的特殊形式



任何一个key都有一个等待队列,不同的key有不同的等待队列。



yield：线程让步，就是当前线程放弃当前cpu执行权利。让当前线程回到就绪状态。



#### 多线程的优点：

可以在同一时间执行更多不同的任务。

#### 在什么场景下使用多线程

1、依赖。业务分为两个执行过程，分别是业务A和业务B，当业务A发生阻塞情况时，B业务的执行不依赖A业务的执行结果，这时可以使用多线程来提高运行效率。如果B业务以来A业务的运行结果，则不可以使用多线程技术。

2、阻塞。一旦系统出现阻塞现象，则可以根据实际情况来使用多线程技术来提高运行效率。