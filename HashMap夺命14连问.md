### HashMap的底层数据结构是什么

在JDK1.7中和JDK1.8中有区别：

在JDK1.7中，由“数组+链表”组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。

在JDK1.8中，由“数组+链表+红黑树”组成，当链表过长，则会影响HashMap的性能，红黑树搜索的时间复杂度是O(logn),而链表是O(n)。因此，JDK1.8对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：

·当链表超过8且数组长度（数据总量）超过64才会转化为红黑树

·将链表转换成红黑树前会进行判断，如果当前数组的长度小于64，那么会选择进行数组扩容，而不是转化为红黑树，减少搜索时间。

### HashMap的特点

·hashmap取值是无序的

·键和值位置都可以是null，但是键位置只能是一个null

·键位置是唯一的，底层的数据结构是控制键的

·JDK1.8之前数据结构是：链表+数组，JDK1.8之后是：数组+链表+红黑树

·阈值（边界值）>8并且数组长度大于64，才将链表转化为红黑树，变成红黑树的目的是提高搜索速度，提高效率

### 解决hash冲突的办法有哪些？HashMap用的哪种？

解决？Hash冲突的方法有：开放定址法，再哈希法，链地址法（HashMap中常见的拉链法），简历公共溢出区。HashMap采用的是链地址法。

·开放定址法也称为再散列法，基本思想就是，如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H(p),如果p1再次出现冲突，则以p1为基础，以此类推，知道找到一个不冲突的哈希地址pi。因此开放定址法所需的hash表的长度要大于等于所需要存放的元素，而且因为存放在再次hash，所以只能在删除的节点上做标记，而不能怎正删除节点。

·再哈希法（双重散列，多重散列），提供多个不同的hash函数，R1=H1(key1)发生冲突时，再计算R2=H2(key1),直到没有冲突为止。这样做虽然不易产生堆集，但增加了计算时间。

·链地址法（拉链法），将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表中的第i个元素，查找，插入和删除主要在同义词链表中进行，链表法适用于进行插入和删除的情况。

·建立公共溢出区，将哈希表分为公共表和溢出表，当溢出时，将所有溢出数据统一放到溢出区。

### 为什么要在数组长度大于64之后，链表才会进行红黑树

在数组比较小的时候如果出现红黑树，反而会降低效率，而红黑树需要再进行左旋右旋，变色，这些操纵来保持平衡，同时数组长度小于64时，搜索时间相对要快一些，总之是为了加快搜索速度，提高性能。

JDK1.8以前HashMap的时间是数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布，当HashMap中有大量的元素存放在同一个桶时，这个桶下有一条长长的链表，此时HashMap就相当于单链表，假如单链表中有n个元素，遍历的时间复杂度就从O(1)退化成O(n),完全失去它的优势，为了解决此种问题，JDK1.8中引入了红黑树，（查找的时间复杂度为O(logn)）来优化这种问题

### 为什么加载因子设置为0.75,初始化的临界值是12？

HashMap中的threshold是HashMap所能扩容纳键值对的最大值，计算公式为length*LoadFactory。也就是说，在数组定义好长度之后，负载因子越大，所容纳的键值对也就越大。

loadFactory越趋进与1，那么数组中存放的数据(entry也就越多)，数据也就越密集，也就会有更多的链表长度处于更长的数值，我们的查询效率就会越低，当我们添加数据，产生hash冲突的概率也就越大。

默认的loadFactory是0.75，loadFactory越小，越趋进于0，数组中存放的数据(entry)也就越少，表现的更稀疏。

0.75是对空间和时间效率的一种平衡选择

如果负载因子小一些，比如是0.4，那么初始长度16*0.4=6，数组占满6个空间就进行扩容，很多空间可能元素很少甚至没有元素，会造成大量的空间被浪费。

如果负载因子大一些比如是0.9,这样会导致扩容之前查找元素的效率非常低

loadFactory设置为0.75是经过多重计算检验得到的可靠值，可以最大程度的减少rehash的次数，避免过多的性能消耗。

### 哈希表底层采用何种算法计算hash值，还有哪些算法可以计算出hash值

hashcode方法是Object中的方法，所有的类都可以对其进行使用，首先底层通过调用hashCode方法生成初始hash值h1，然后将h1无符号右移16位得到h2，之后将h1与h2进行按位异或(^)运算得到最终hash值h3，之后将h3(length-1)进行按位与(&)运算得到hash表索引。

其他计算hash值的算法有

·平方取中法

·取余法

·伪随机数法

### 当两个对象的hashcode相等时会怎样？

hashcode相等产生hash碰撞，hashcode相等就会调用equals方法比较内容是否相等，内容如果相等则会进行覆盖，内容如果不等则会进行连接的链表的后方，链表长度超过8且数组长度超过64，会转变成红黑树节点。

### 发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞？

只要两个元素的key计算的hash码值相同就会发生hash碰撞，jdk8之前使用链表解决hash碰撞，jdk8之后使用红黑树+链表解决hash碰撞。

### HashMap的put方法流程

以jdk8为例，流程如下：

·首先根据key的值计算hash值，找到该元素在数组中存储的下表

·如果数组是空的，则会调用resize进行初始化

·如果没有哈希冲突直接放在对用的数组下标里

·如果冲突了，且key已存在，就覆盖掉value

·如果冲突后是链表结构，就判断该链表是否大于8，如果大于8并且数组容量小于64，就进行扩容，如果链表节点数量大于8并且数组的容量大于64，则将这个结构转换为红黑树，否则，链表插入键值对，若key存在，就覆盖value

·如果冲突后，发现该节点是红黑树，就将这个节点挂在树上

### HashMap扩容方式

HashMap在容量超过负载因子所定义的容量之后，就会扩容，java里的数组是无法自己扩容的，将HashMap的大小扩大为原来数组的两倍

### 一半用什么作为HashMap的key

一半用Integer，String，这种不可变类当HashMap的key

·因为Stirng是不可变的，当创建字符串时，它的hashcode被缓存下来，不需要再次计算，相对于其他对象更快

·因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的，这些类很规范的重写了hashCode()以及equals()方法

### 为什么Map桶中节点个数超过8猜转换为红黑树？

8作为阈值作为HashMap的成员变量，在源码中的注释并没有说明阈值为什么是8，在数节点占用空间是普通Node的两倍，如果链表节点不够却转换为红黑树，无疑会损耗大量的空间，并且在随机hash算法下的所有bin节点分布频率遵循从泊分布，链表长度达到8的概率只有0.00000006，几乎是不可能事件，所以8的计算是经过重重科学考量的。

·从平均查找长度来看，红黑树的平均查找长度是logn，如果长度为8，则logn=3，而链表的平均查找长度为n/4，长度为8时，n/2=4，所以阈值8能大大提高搜索速度

·当长度为6时，红黑树退化为链表是因为logn=log6约等于2.6，而n/2=6/3=6 两者相差不大，而红黑树节点占用更多的内存空间，所以此时转换为比较好

### HashMap线程不安全？

多线程下扩容死循环，jdk1.7中的HashMap使用的头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的存在，形成死循环，因此jdk1.8中使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题

多线程的put可能导致元素的丢失，多线程同时执行put操作，如果计算出来的索引位置是相同的，那会造成前一个key被后一个key覆盖，从而导致元素的丢失，次问题在jdk1.7和jdk1.8都存在

put和get并发时，可能导致get为null，线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题，此时问题在jdk7和jdk8中都存在，

### 计算hash值时为什么要让低16bit和高16bit进行异或处理

我们计算索引需要将hashCode值于lenght-1进行按位与运算，如果数组长度很小，比如16，这样的值和hashCode做异或实际上只有hashCode值的后4位在进行计算，hash值是一个随机值，如果产生hashCode值高位变化很大时，而低位变化很小，那么有很大的概率造成哈希冲突，所以我们为了使元素更好的散列，将hash值的最高位也利用起来

























